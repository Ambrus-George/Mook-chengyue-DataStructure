# Mook-陈越，何钦明-数据结构-2025夏季
Mook浙江大学-陈越，何钦明两位老师开设的数据结构课程，这个仓库整理下自己在该课程PTA习题集上提交的程序，加油，希望自己坚持做完！
## 第一周
1. [最大子列和问题](/CodeFiles/MSSum.c)
2. [Maximum Subsequence Sum](/CodeFiles/MSSumPlus.c)
3. [二分查找](/CodeFiles/BisMethod.c)

## 第二周
1. [两个有序链表序列的合并](/CodeFiles/Merge1.c)
    > malloc(sizeof(PtrToNode)) 和 malloc(sizeof(struct Node))的效果一样，申请到的都是这个结构空间，不太理解，`sizeof` 这个函数的操作数如果是结构体和结构体指针，结果一样？这也太奇怪了，需要查下
2. [一元多项式的乘法与加法运算](/CodeFiles/AddMultiList.c) + [insert改良版](/CodeFiles/AddMultiList1.c)
    > 这个题的思路很简单；最主要的一个函数就是 `void insertNode()` 这个函数负责传入的列表和需要新建的结点数据，来将新节点加入到这个列表中的合适位置
    
    ```diff
    + 对于加法来说，只需要不断地比较两个列表，挑选出指数大的结点添加上去就行了
    - 对于乘法来说，同样简单，列表1中的每个结点和整个列表2相乘，结果一个个加到新列表中
    ```

    > 需要注意的是，加法中会有0系数项合并，乘法中也会有，虽然相乘不会出现0系数同类项，但是四个结点是会有这种情况发生的，如此这般，就要求 `insertList` 函数更强壮

    ```diff
    - 可是，insert函数强壮了，那很多判别的事情交给它就可以了，乘法，加法的函数反而简单了
    - 因此，就要对整体函数进行改良了；其实说是改良，也就是把加法函数中的判定条件直接删了
    - 计算加法结果，就傻傻地一个个结点添加就行了，至于结点放在哪儿，结点合并，结点删除，全交给 insert 函数就好了
    ```
3. [Reversing Linked List](/CodeFiles/ReversingList.c) + [两年后的版本](/CodeFiles/ReversingList1.cpp)
    > 虽然通过了全部测试点，但并不强壮，自测的时候发现 如果K 的取值为 0 ，会发生段错误，但显然陈越老师的测试点没有提及这一点；另外，由于自己写程序的时候，根本没有想到还有多余的结点，对应测试点6，所以，我当时还纳闷，这个尾地址根本没用呀，只要最后一个结点，我直接输出尾巴是 -1就好了，自作聪明了，早知道这样，程序就不这样写了，但我懒得改了，就这样吧，由于以上两个原因，程序可以完善，但我不

    > 可怕的自制力，谁能想到我再次学这个课程已经两年后了，唉，差劲，总之呢，两年后再写，还是进步了一些的，很多地方其实是避免了，但是出现了新问题，使用链表的时候，删除部分给自己造成了麻烦，C++对指针管控很严格，不可以释放已经释放的空间，自己偷懒，没有建立新的空间用，用原来的，就出问题了，另外，不在链表中的空闲结点，自己还是没有考虑到，但这个简单，程序改起来就换个循环条件，好在自己留的后手够多
4. [Pop Sequence](/CodeFiles/PopSequence.c) + [模拟出入堆版本](/CodeFiles/PopSequence.cpp)
    > 好复杂，我使用的方法不太一样，别人都是模拟入栈出栈，我完全是找规律，要想判断，需要有两条得满足：
    ```diff
    + 1.想要输出这个样子的队列，堆栈的容量是否满足，也就是超没有超
    - 输出的顺序要正确，比如说不能有“7 5 6”这样的顺序，像个山谷一样
    ```
    > 本来还有点心情，试一下模拟的方法，但使用这个的时候，遇到了一个很讨厌的段错误，程序中我存储数据的二维数组本来是这样写的 `num[MAXSIZE][MAXSIZE]` 这里的 `MAXSIZE` 定1000（根据题目）但结果就是还没有进入主函数，就遇到 `segmentation fault`，但是这样提交也没有问题，但在我的电脑上无法运行，只有使用变量来定义才行 `num[K][N]` ，原因可能是，main函数调用的栈空间太大了，这个真的麻烦，很想知道如果避免

## 第三周
1. [树的同构](/CodeFiles/IsomorphicTree.c) + [版本2](/CodeFiles/IsomorphicTree.cpp)
    > 这道题感觉好难，没有老师的小白专场，感觉自己几天都做不出来，真是菜；感觉难点在于：1.理解题意，题中的输入本身就是按照数组给的，输入的左子树，右子树，就是数组顺序，知道了这一点，就可以下手；2.判断两个树是否是同构，用的迭代方法，经过老师之前的授课，感觉迭代最好不用，这道题需要使用，另外就是思维逻辑，能够将所有的情况想清楚，这个需要训练啊

    > 另外，又遇到了自己电脑上运行有问题，提交上去运行没问题的情况，估计是gcc版本不同导致的吧，自己电脑上输入不对，真是垃圾，用c++或者java写可能就不会有这样的问题了
2. [List Leaves](/CodeFiles/ListLeaves.c) + [版本2](/CodeFiles/ListLeaves.cpp)
    > 做完了 `树的同构` 这道题，这个题的思想方法一致，多了一个层序遍历的问题，按照何老师的授课，可以通过队列来实现层序遍历，我使用数组的方法实现队列（该队列较为简单，只对这道题有用），由于不熟悉队列，花了不少时间，真笨
   
    > 使用了固定数组来实现队列，这样总是从下标为1开始pop，这样就会造成头和尾的下标两个一起变，所以，以后尽可能用单链表来实现队列好了，堆先进后出，没有这个问题，用数组还挺方便的
3. [Tree Traversals Again](/CodeFiles/TTraAgain.c)
    > 需要讨巧，Push 进去的队列就是 `PreOrder` ；Pop 出来的队列就是 `InOrder` ；已经知道两个顺序，就可以推出 `PostOrder`。

## 第四周
1. [是否同一棵二叉搜索树](/CodeFiles/IsSameTree.c) + [版本2](/CodeFiles/IsSameTree.cpp)
    ```diff
    - 我用的最愚蠢的办法，分别建立两棵树，然后判定是不是同结构的树
    + 第二种方法是不用建立树，找到根，比他小的一堆在左，大的在右，递归查看左右
    + 第三种方法是何老师教的，建立一棵树，利用flag位，查看结点的路径上没有遇到新的结点，那么就是一样的树
    ```
2. [Root of AVL Tree](/CodeFiles/RootAVLTree.c) + [版本2](/CodeFiles/RootAVLTree.cpp)
    > 难点在于如何能够判断出什么时候该进行四种旋转，递归函数实现，从树的底部到顶部的结点的左右高度判定，判定成立，就进行旋转
   
    > 本来想写不使用迭代版本的，所以insert函数可以不迭代插入，但是revert的时候忘了让旋转后的结构和父节点建立联系，如果按照我原来的思维继续写，那就是遍历，但这样就更复杂了，需要改一次，遍历一次，从头到尾改，肯定不如从脚到头改，所以，最后还是选择，插入的时候顺便检测BalenceFactor，然后进行revert，然后从改变的地方向上更新结点高度

    ```diff
    - 版本2中的inset函数，注意，如何更新root指针的问题
    + 思考，如何不用迭代，代码肯定会更复杂，但可以试试，看后续版本3会不会出来吧，很有可能又要2年才能写版本3，哈哈哈哈
    ``` 
3. [Complete Binary Search Tree](/CodeFiles/CBSTree.c) + [版本2](/CodeFiles/CBSTree.cpp)
    > 需要熟悉完全二叉树的排序方式，使用数组来表示该完全二叉树

    > 这道题做起来就很麻烦，遇到的卡壳点儿在于递归调用的这个函数，我最开始的想法是，从数组起始位到终止位，找到根结点，然后左边就是左子树，右边就是右子树，递归处理左子树，再递归处理右子树，这样子得到的是完全二叉树的先序遍历的结果，接下来也可以做，两个思路，建立树，一个一个插结点就行，或者是找到先序遍历和层序遍历的对应关系，毫无疑问，两种方法都是比较复杂的，查看了网上大家的方法，还是基本性质不熟悉导致卡壳，总的递归调用思路是，递归地将根节点插入到为层序遍历准备的数组中，开头先处理第一个值，这里index来表示，也就是全部的根结点，接下来递归处理它的左结点，下标也就是 index*2，长度就是 left -- (index-1)， 这样全部处理完左子树后，递归处理右子树，下标也就是 index * 2 + 1， 长度就是 （index + 1） -- right

    ```diff
    - 完全二叉树层序遍历的数组，根节点下标是 i, 左节点下标是 i * 2, 右节点下标是 i * 2 + 1
    ```
5. [二叉搜索树的操作集](/CodeFiles/BSTMethods.c)

## 第五周
1. [堆中的路径](/CodeFiles/LoadsInMinheap.cpp)
   > 开始写的程序是按照先把数据都读入，然后从 （n/2）结点开始，从下到上，从右到左，percolate down数据，这样子形成的最小堆不是测试数据的最小堆，所以，又在程序中写了 insert 函数，两种 sort 方法都有了
3. [File Transfer](/CodeFiles/FileTransfer.cpp)
    > 从这里开始，以后就用 C++ 写了，反正 C++，也可以兼容 C，何不利用这次机会，学习一下 C++ 呢？虽然刚开始一眼看上去就是 C 的逻辑和写法，但慢慢来吧

    > 通过陈越老师的讲授，一步步照搬来的，理清思路其实不难，陈越老师所讲的程序，有两个重点，也是老师分别用单独的视频所讲的

    ```diff
    - Find 函数不仅仅是要找到根结点，还要通过不断的递归调用，使得树的高度变低
    + 根结点指向负值，这个负值可以用来表示这个集合中一共有几个结点
    ```
4. [Huffman Codes](/CodeFiles/HuffmanCodes.cpp) + [我的错误版本](/CodeFiles/HuffmanCodes_AmbGeo.cpp)
    > 写得太复杂了，最后修改下来，还有有一个测试点没有通过，最大N&M，不明白为啥，使用AI修改的代码很简洁，后面再改改看，完善完善     

## 第六周
1. [列出连通集](/CodeFiles/ListGroup.cpp)
   > 写出来太复杂了，使用上半角来存储最多10个点的数据太麻烦容易出错，写出来的这个对于第二个测试点过不去，原因未知，待修正，第二个测试提示 “第一个点是单独点，最大N”
   
2. [Saving James Bond](/CodeFiles/SavingJamesBond.cpp)
   > 这道题很简单的，一开始的时候计算结果不正确，排查之后是因为在DFS寻路过程中，如果跳到了一个鳄鱼的位置，后面发现从这个位置找不到正确的路线，那就要退回到上一个位置，所以，每次DFS时，要记录当前位置，再去寻找路线
   
   ```diff
   - vector 已经声明的数组,对其统一初始化，可以使用 resize 函数，也可以使用 fill 函数
   - 也可以预分配数组大小然后使用push_back
   + 求绝对值可以使用 <cmath> 中重载的函数 abs() ，非常方便 
   ```
   
   ```cpp
   std::vector<int> vec;
   vec.resize(10);          // 10个元素，默认初始化为0
   vec.resize(15, -1);       // 调整为15个元素，新元素初始化为-1

   #include <algorithm>
   std::vector<std::string> vec(5); // 5个空字符串
   std::fill(vec.begin(), vec.end(), "default"); // 全部设为"default"

   std::vector<int> optimized;
   optimized.reserve(1000); // 预分配内存，避免push_back时多次重新分配
   for (int i = 0; i < 1000; i++) {
       optimized.push_back(i * 2); // 高效添加元素
   }
   ```
3. [六度空间](/CodeFiles/SixDegreesSpace.cpp)
   > 教训就是永远别用上三角下三角存放数据，真的很不方便

   ```diff
   - cpp 中如何按照设定形式输出，即属于的double 变量有几位小数，可以使用 fixed 
   ```

   ```cpp
   #include <iomanip>

   double item = 1;
   std::cout << std::fixed << std::setprecision(2) << item;
   ```
## 第七周
1. [哈利*波特的考试](/CodeFiles/HerryPotterExam.cpp)
   > 这道题就是“简单”的有权图的多源最短路径的问题，使用 Floyd 算法，跟着陈老师的方法一步一步来其实不难，但我自己觉得从图这里感觉数据结构就变得困难了，当然了，这只是对我来说，这一周的最短路径的课程，很多地方不是很具体，想不清楚，虽然能做出题目来，但是靠着记忆，没有很好地理解概念，没吃透

   ```diff
   + 写题时遇到点儿问题，Data，Dist 数组初始化应该初始化为无穷大
   + 题中要带的动物是想让咒语都不会太长，不是全部咒语加起来太长，真无语啊，我这都不理解
   ```

2. [Saving James Bond - Hard Version(写的第一版，无法通过全部测试点)](/CodeFiles/SavingJamesAgain.cpp)
   </br>
   [按照文章作者的思路，重新写的程序，通过全部测试点](/CodeFiles/SavingJamesAgain1.cpp)
   > 拯救007之前也有这个题目，上次只问了 Bond 能不能活，但是这次要给 Bond 提供路线，而且是最优的路线，其实写代码的时候已经意识到了这一点，甚至我还写了注释，但还是鬼使神差地写下去了，这下好了，从头来过了要，思路其实很简单，就是到了一条鳄鱼头上，看看有没有安全，没有就找下一个跳点，一旦成功了，就结束了
   > 如果从中途中的一个结点开始，有了分叉路，这两条路都可以上岸，代码就没有了判断能力，我思考了很久，也没有什么好办法

    ```diff
   - 我不是 Bond，我是上帝视角，先看哪写鳄鱼可以上岸，再找单源最短路径
   ```

   > 还是没有理解了这部分的知识点，我总感觉，陈老师是个很合格的大学老师，就是不给你讲得很明白，给你留下很多让你自己思考的时间和空间，哈哈哈哈哈哈，言归正传，我从网络上找到一篇文章，文章作者也是初学者，把思路写得特别清楚，一下子就让我打开了思路，强烈建议去看看别人的好思路

   这个作者的文章条理清晰，一看就是很细致的牛人，开个[任意门](https://blog.csdn.net/m0_63938020/article/details/124423084)，去看看大佬的笔迹~~
   
3. [旅游规划](/CodeFiles/TravelMenu.cpp)
   > 不用多说，其实就是比普通的 Dijkstra 算法，多了一个高速费的判断条件，完成了上一题之后，这道题应该算是特别简单，秒了

   ```diff
   + 本题中邻接表中的数据，我是用的申请的结点空间，析构函数进行循环调用的时候，会出现重复删除
   + 因此，在释放了一个空间后，指向这个空间的指针设为 nullptr 是比较合理的习惯
   - 另外，本题多出来的，距离一致时比较高速费的操作，这个环节的进行位置最开始写错了
   - 访问 Dist 最小结点时，循环对它的邻接点写入时，才进行这个操作
   ```

## 第八周
1. [公路村村通](/CodeFiles/VillageRoads.cpp)
   > 我是使用 Kruskal 算法来做这道题的，Kruskal 算法中需要用到并查集的知识，但我最开始写的代码，并查集的操作代码写得不规范，造成了混乱和错误，导致有几个测试点不通过

   ```cpp
   // 以下是 AI 写的操作集，清楚明白，AI 比我强多了
   class UnionFind {
    private:
        std::vector<int> parent;
        std::vector<int> rank;
        
    public:
        UnionFind(int n) {
            parent.resize(n + 1);
            rank.resize(n + 1, 0);
            for (int i = 1; i <= n; i++) {
                parent[i] = i;
            }
        }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
    
    bool merge(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) {
            return false;
        }
        
        // 按秩合并
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
    
    bool isConnected(int x, int y) {
        return find(x) == find(y);
    }
    };
   ```
   
   ```diff
   + 我最开始写的 while 循环条件有一条是访问过也就是成为树的结点是不是全部的结点
   + 但其实这样写是很麻烦的，不看结点，看边就好了，N个结点，想要最小生成树，一定是N-1条边
   + 如果图不连通，那么访问过所有的边后，能选中的边一定小于 N-1
   ```
2. [How Long Does It Take](/CodeFiles/ProjectSchedule.cpp)
   > 按照陈越老师后面讲的实现方法来实现，这道题其实挺简单的，代码写好，基本没有改就能通过全部测试点了
   > 过程需要铭记，实际问题中，点是检查点，边是实际项目进程
   
3. [关键活动](/CodeFiles/KeyAction.cpp)
   > 真服了，看到题目其实觉得很简单，在昨天的基础上改改就行，结果一道题绊住我一天，一是基本概念掌握得不好，导致逻辑上很难理顺
   > 后来就看了一眼陈老师的讲义，一下子豁然贯通

   ```diff
   + 要点1：更新一个检查点的截止时间，是从它的出度的几个活动中看
   +       从几个出度的活动中计算其 min 值，也就是最紧张的时间
   - 要点2：更新检查点的 DeadLine 是从后往前，按照逆拓扑顺序（即拓扑排序的逆序）更新每个顶点的最晚时间
   -       我这里想复杂了，总觉得这样不能保证每个检查点的 DeadLine 时间可以正常算下去，但实际上是可以的
   -       拓扑排序的意思就是前面的基础都铺好了，后面就可以进行了，反过来同样如此
   -       想通之后也就不难了，在之前计算最快完成时间时是使用队列，度为0 的入，然后出，出队的时候入栈不就行了
   + 拓扑排序的终点的 DeadLine 时间是确定的就是最快完成时间，所以，栈的好处就是可以出栈的时候加个条件
   + 判断最开始出来的几个是不是都是终点（因为可能不止一个终点），我是在邻接表中看有没有出度
   + Deep seek建议，建立图的时候不止要建立邻接表，也要建立邻接矩阵
   + Deep seek建议，可以用逆向邻接表来解决问题
   ```

   > 总之吧，程序是没问题的，但是因为思路变来变去，我自己闭门造车的时候想了好几种不对的思路，做了一半就发现有问题，然后重新来，导致程序中有几个不需要的变量和构件，我也懒得改了，但是我觉得最后我的整体的解决方法还是很不错的，其实想通了就是很简单的题目

## 第九周
1. [排序](/CodeFiles/Sort1.cpp)
   > 生成SedgewickSequence遇到点儿麻烦，陈老师讲义上的公式不对，在网上查的实现公式
   > 希尔排序的的实现方式是，比如当前 gap 是5，从下标5开始，以5为间隔，比较5，0，的大小，使用插入排序调整位置，然后比较6，1，...，然后比较 10，5，0 的大小...
   
   ```cpp
   typedef long int ElementType;
    typedef int IndexType;
    
    void generateSedgewickSequence(std::vector<IndexType>& Q, IndexType N)
    {
    	Q.clear();
    	IndexType k = 0;
    	IndexType gap = 0;
    	while (true)
    	{
    		if (k % 2 == 0)
    		{
    			gap = 9 * (pow(2, k) - pow(2, k / 2)) + 1;
    		}
    		else
    		{
    			gap = 8 * pow(2, k) - 6 * pow(2, (k + 1) / 2) + 1;
    		}
    		if (gap > N) break;
    		if (gap > 0)
    			Q.push_back(gap);
    		k++;
    	}
    	std::reverse(Q.begin(), Q.end());
    	return;
    }


   // 希尔排序
    for (auto gap : SedgewickSequence)
    {
    	decltype(gap) i, j;
    	for (i = gap; i < N; i++)
    	{
    		auto Tmp = Data.at(i);
    		for (j = i; j >= gap && Data.at(j - gap) > Tmp; j -= gap)  //注意这里的判断条件
    		{
    			Data.at(j) = Data.at(j - gap);
    		}
    		Data.at(j) = Tmp;
    	}
    }
   ```

2. [Insert or Merge](/CodeFiles/Sort2.cpp)
   > 其实熟悉了插入排序和合并排序，这道题很简单，我的思路就是，每种排序去检测是否进行了一次有效的排序变换，代码中管它叫做 “onestep”

   ```diff
   + 同类型比较，不要 size_t 和 int 进行比较

   - for(auto& tmp : Data) 注意加引用，否则会创建副本，不改变原成员

   + decltype 使用时注意 int 和 int&, 在函数变量中经常容易出错

   - 这道题，如果有例子可以称它是插入排序的结果，也可以称它是合并排序的成果
   - 如果是这样子的情况的话，测试程序默认是插入排序
   - 也正是因为这一点，我最开始的程序无法通过一个测试点
   - 这个测试点提示为：最小N，inQ, 第一次变换无效
   - 我改了代码顺序，让这种情况的序列统一默认是插入排序就通过了
   ```


3. [Insertion or Heap Sort](/CodeFiles/Sort3.cpp)
   > 简单，和上一题基本一样，这次比较两排序是堆排序还是插入排序，在上一题的代码上加个控制堆排序的函数就OK了
   ```diff
   + 完全二叉树​：除了最后一层，其他层都是满的，并且最后一层节点从左到右连续排列

   + 数组表示​：节点在数组中的索引按层级顺序排列
   +   根节点：索引 0
   +   节点 i 的：
   +      左子节点索引：2i + 1
   +      右子节点索引：2i + 2
   +      父节点索引：(i - 1) / 2 (整数除法)

   + 叶子节点从索引 (N/2) 开始
   +   ​最后一级叶子节点​：总数 ≈ 总节点数的一半
   +   在 N 个节点的完全二叉树中：
   +      非叶子节点数：floor(N/2)
   +      叶子节点数：ceil(N/2)

   + 最后一个父节点的索引推导
   +   由于树是自顶向下填充，最后一个父节点是最后一个拥有子节点的节点
   +   ​最后一个父节点必然是：
   +      倒数第二层的最右边节点
   +      其索引为最大的非叶子节点索引

   + 数学证明：
   +   设最后父节点索引为 k，则：
   +   其子节点最大索引为 2k + 2（如果存在）
   +   所有节点索引范围是 [0, N-1]
   +   因此：2k + 2 ≤ N - 1
   +      ⇒ k ≤ (N - 2)/2
   +      ⇒ 最大整数 k = floor(N/2) - 1
   ```

## 第十周
1. [统计工龄](/CodeFiles/Sort4.cpp)
   > 小学生题目，没必要快速排序

2. [PAT Judge(自己写的最后一个测试点不通过)](/CodeFiles/Sort5.cpp) + [chatgpt生成版](/CodeFiles/Sort5_chatgpt.cpp)
   > 唉，使用的是插入排序，结果时间复杂度是O(N^2), 最后一个测试点不通过，chatgpt 10秒写出来的代码完虐我，好烦，人生好烦

   ```cpp
   // 如何设置输出格式：
   #include <iomanip>
   int a = 5;
   std::cout << std::setfill('0') << std::setw(5) << a << std::endl;
   ```

3. [Sort with Swap(0, i)](/CodeFiles/Sort6.cpp) + [chatgpt参考版](/CodeFiles/Sort6_chatgpt.cpp) + [deepseek参考版](/CodeFiles/Sort6_deepseek.cpp)
   > 自己完全想不出来头绪，通过询问 chatgpt，找到了思路

   <br>

   1. 问题的本质：
      借助 '0', 把 0 当做一个中转站，把元素逐步放回它们应该在的位置
   2. 排列的结构：置换环
      任何一个排列都可以分解成 若干个环 (cycle)
      例如：
      排列：[4, 0, 2, 1, 3]，对应的映射关系是：
      * 0 → 4
      * 4 → 3
      * 3 → 1
      * 1 → 0 （回来了，形成一个环）
      * 2 → 2 （自己就是一个环）
      所以排列由一些环组成
   3. 排序过程的本质
      要把排列变为有序，需要“打破每个环”，让元素回到它该在的位置
      * 如果环中 包含 0，很好办，直接在这个环内循环交换就能完成。
          * 长度为 k 的环，需要 k-1 次交换。
      * 如果环中 不包含 0，那你得先把 0 换进来，再操作，再换出来。
          * 长度为 k 的环，需要 k+1 次交换。
        
   <br>

   > 我是完全按照这个思路来做的，但是，过程中判断这个环结束了没有，是陈越老师课程中提到的方法，即，一个元素排好了顺序，我就把它的数据改变，这样其下标和数据一致，
   > eg. data[1] = 1，这样就判定为这个环结束了，但是，无论是chatgpt写出来的代码还是deepseek写出来的，均是使用swap()函数来把0给换出去
   > 原因好像是说我这样子破坏了环结构啥的，会导致出错，细致的东西我就不考虑了，以后有机会，再琢磨一般

## 第十一周
1. [散列1 电话聊天狂人（最后一个测试点始终不通过）](/CodeFiles/Hash1.cpp) + [别人的优秀代码参考](/CodeFiles/Hash1_0.cpp)
   > 我的想法是，初始 K 为 1，数组成员是一个结构体存放每个电话用户，数组大小是 4*K+3，每次有新用户登记，就检查填装因子，不行就扩大K值，扩大到填装因子在 0.5 以下
   > 有单独的指针记录通话次数最多的用户，用指针指向这个结构体，然后也有单独的计数器记录同样是最多通话次数的用户数

   > 那我存在的问题总结为以下：
   > 1. 4 * K + 3 不全是素数，这个数组的大小应该是质数，否则会出现有空位，但一直找不到的情况
   > 2. 记录最多通话次数的指针这个有问题，因为原始数组会扩大，我使用了resize，这样，会重新分配内存，指针需要刷新才能使用，我的做法是，先扩大，然后，新建一个数组，将旧数组中的数据重新计算后放在临时数组中，然后旧数组=临时新数组，整个复制过来，然后再找到通话次数最多的用户结构体
   > 3. 总结问题2中仍然有问题，不说效率地，还会出现问题，具体问题是啥，我还没有弄清楚，但绝对有问题，可以最后再处理最值的问题，不用过程中处理，用一个 vector 数组，记录最多次数的结构体指针，遇到更多次数的就清空这个数组，新指针记录，同样次数的继续记录，最后，用 std::min_element 来找到号码最小的结构体
   > 4. 另外 hash 冲突处理能力不足，我最开始，有些用户转化成的 key 值是一样的，这样肯定不行，这个我还没有多少头绪

2. [散列2 Hashing](/CodeFiles/Hash2.cpp)
   > 题目很简单，过程中犯了一个错误，对象转化为 key 值之后，这个是旧位置，冲突后应该是 oldposition + 1^2 / 2^2 / ...，但我加了一个，就直接更新了 key ,下一次，用 key 来加，这样肯定不对，这个错误导致过不去两个测试点，这个还是AI看出来的

3. [散列3 QQ账户的申请和登录（改良版）](/CodeFiles/Hash3.cpp) + [deepseek建议版](/CodeFiles/Hash3_deepseek.cpp)
   > string类中 substr 的使用

   > 1. 哈希函数设计问题：（大问题）
   >    1. 创建了大量临时字符串
   >    2. 使用了嵌套循环
   >    3. 最后只取模1000，导致哈希值范围太小，冲突过高
   > 2. 哈希表扩展问题：（直接问题）
   >    1. 需要多次扩展
   >    2. 每次扩展都要重新计算哈希值，重来一遍
   > 3. 平方探测可能不太高效（次要问题）
   >    1. 计算复杂度
   >       1. 您的实现需要计算 (count + 1) * (count + 1) / 4和 count * count / 4
   >       2. 简单正增量只需计算 j * j
   >    2. 分支预测
   >       1. 您的实现有 if (++count % 2)分支，CPU分支预测失败会带来性能损失
   >       2. 简单正增量无分支，执行更高效
   >    3. 缓存局部性​
   >       1. 正负跳跃可能导致缓存不命中率更高
   >       2. 正增量序列更连续，缓存友好性更好

   ```cpp
    #include <iostream>
    #include <vector>
    #include <string>
    
    int main() {
        std::string str = "abcdefghijklmnopqrstuvwxyz";
        int chunkSize = 3;
        std::vector<std::string> chunks;
        
        // 从后向前提取
        while (!str.empty()) {
            int take = std::min(chunkSize, static_cast<int>(str.length()));
            chunks.push_back(str.substr(str.length() - take));
            str.resize(str.length() - take);
        }
        
        // 输出结果（从后向前）
        std::cout << "从后向前提取:\n";
        for (const auto& chunk : chunks) {
            std::cout << chunk << "\n";
        }
        
        // 输出结果（从前向后）
        std::cout << "\n从前向后提取:\n";
        for (auto it = chunks.rbegin(); it != chunks.rend(); ++it) {
            std::cout << *it << "\n";
        }
        
        return 0;
    }
   ```
4. [散列4 Hashing --Hard Version（我写的错误版本）](/CodeFiles/Hash4.cpp) + [拓扑排序正确版](/CodeFiles/Hash4_deepseek.cpp)
   > 我最开始想法是，建立一个差值数组，这个就可以反应谁先输入，谁后输入，当抛出一个后，同样的余数位置上的结点差值减1，然后，把原始数组上后面的（需要减1的）结点减1

   > 但问题是，这个需要减1的很难通过找规律写出来，所以，从逻辑上就错误了，最后一个测试点无法通过，最后一个测试点是大规模数据，当数据规模小的时候，代码能碰巧正确，但数据规模起来，就会犯错，所以，这个还是要用拓扑排序，计算入度

## 第十二周

[KMP 字符串匹配算法比较](/CodeFiles/KMP.cpp)

KMP算法，设计得相当精妙，网络上的这篇文章写得很详尽，这里给个[任意门](https://www.cnblogs.com/labuladong/p/13933781.html)















