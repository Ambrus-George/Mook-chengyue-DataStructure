# Mook-陈越，何钦明-数据结构-2025夏季
Mook浙江大学-陈越，何钦明两位老师开设的数据结构课程，这个仓库整理下自己在该课程PTA习题集上提交的程序，加油，希望自己坚持做完！
## 第一周
1. [最大子列和问题](/CodeFiles/MSSum.c)
2. [Maximum Subsequence Sum](/CodeFiles/MSSumPlus.c)
3. [二分查找](/CodeFiles/BisMethod.c)

## 第二周
1. [两个有序链表序列的合并](/CodeFiles/Merge1.c)
    > malloc(sizeof(PtrToNode)) 和 malloc(sizeof(struct Node))的效果一样，申请到的都是这个结构空间，不太理解，`sizeof` 这个函数的操作数如果是结构体和结构体指针，结果一样？这也太奇怪了，需要查下
2. [一元多项式的乘法与加法运算](/CodeFiles/AddMultiList.c) + [insert改良版](/CodeFiles/AddMultiList1.c)
    > 这个题的思路很简单；最主要的一个函数就是 `void insertNode()` 这个函数负责传入的列表和需要新建的结点数据，来将新节点加入到这个列表中的合适位置
    
    ```diff
    + 对于加法来说，只需要不断地比较两个列表，挑选出指数大的结点添加上去就行了
    - 对于乘法来说，同样简单，列表1中的每个结点和整个列表2相乘，结果一个个加到新列表中
    ```

    > 需要注意的是，加法中会有0系数项合并，乘法中也会有，虽然相乘不会出现0系数同类项，但是四个结点是会有这种情况发生的，如此这般，就要求 `insertList` 函数更强壮

    ```diff
    - 可是，insert函数强壮了，那很多判别的事情交给它就可以了，乘法，加法的函数反而简单了
    - 因此，就要对整体函数进行改良了；其实说是改良，也就是把加法函数中的判定条件直接删了
    - 计算加法结果，就傻傻地一个个结点添加就行了，至于结点放在哪儿，结点合并，结点删除，全交给 insert 函数就好了
    ```
3. [Reversing Linked List](/CodeFiles/ReversingList.c) + [两年后的版本](/CodeFiles/ReversingList1.cpp)
    > 虽然通过了全部测试点，但并不强壮，自测的时候发现 如果K 的取值为 0 ，会发生段错误，但显然陈越老师的测试点没有提及这一点；另外，由于自己写程序的时候，根本没有想到还有多余的结点，对应测试点6，所以，我当时还纳闷，这个尾地址根本没用呀，只要最后一个结点，我直接输出尾巴是 -1就好了，自作聪明了，早知道这样，程序就不这样写了，但我懒得改了，就这样吧，由于以上两个原因，程序可以完善，但我不

    > 可怕的自制力，谁能想到我再次学这个课程已经两年后了，唉，差劲，总之呢，两年后再写，还是进步了一些的，很多地方其实是避免了，但是出现了新问题，使用链表的时候，删除部分给自己造成了麻烦，C++对指针管控很严格，不可以释放已经释放的空间，自己偷懒，没有建立新的空间用，用原来的，就出问题了，另外，不在链表中的空闲结点，自己还是没有考虑到，但这个简单，程序改起来就换个循环条件，好在自己留的后手够多
4. [Pop Sequence](/CodeFiles/PopSequence.c) + [模拟出入堆版本](/CodeFiles/PopSequence.cpp)
    > 好复杂，我使用的方法不太一样，别人都是模拟入栈出栈，我完全是找规律，要想判断，需要有两条得满足：
    ```diff
    + 1.想要输出这个样子的队列，堆栈的容量是否满足，也就是超没有超
    - 输出的顺序要正确，比如说不能有“7 5 6”这样的顺序，像个山谷一样
    ```
    > 本来还有点心情，试一下模拟的方法，但使用这个的时候，遇到了一个很讨厌的段错误，程序中我存储数据的二维数组本来是这样写的 `num[MAXSIZE][MAXSIZE]` 这里的 `MAXSIZE` 定1000（根据题目）但结果就是还没有进入主函数，就遇到 `segmentation fault`，但是这样提交也没有问题，但在我的电脑上无法运行，只有使用变量来定义才行 `num[K][N]` ，原因可能是，main函数调用的栈空间太大了，这个真的麻烦，很想知道如果避免

## 第三周
1. [树的同构](/CodeFiles/IsomorphicTree.c) + [版本2](/CodeFiles/IsomorphicTree.cpp)
    > 这道题感觉好难，没有老师的小白专场，感觉自己几天都做不出来，真是菜；感觉难点在于：1.理解题意，题中的输入本身就是按照数组给的，输入的左子树，右子树，就是数组顺序，知道了这一点，就可以下手；2.判断两个树是否是同构，用的迭代方法，经过老师之前的授课，感觉迭代最好不用，这道题需要使用，另外就是思维逻辑，能够将所有的情况想清楚，这个需要训练啊

    > 另外，又遇到了自己电脑上运行有问题，提交上去运行没问题的情况，估计是gcc版本不同导致的吧，自己电脑上输入不对，真是垃圾，用c++或者java写可能就不会有这样的问题了
2. [List Leaves](/CodeFiles/ListLeaves.c) + [版本2](/CodeFiles/ListLeaves.cpp)
    > 做完了 `树的同构` 这道题，这个题的思想方法一致，多了一个层序遍历的问题，按照何老师的授课，可以通过队列来实现层序遍历，我使用数组的方法实现队列（该队列较为简单，只对这道题有用），由于不熟悉队列，花了不少时间，真笨
   
    > 使用了固定数组来实现队列，这样总是从下标为1开始pop，这样就会造成头和尾的下标两个一起变，所以，以后尽可能用单链表来实现队列好了，堆先进后出，没有这个问题，用数组还挺方便的
3. [Tree Traversals Again](/CodeFiles/TTraAgain.c)
    > 需要讨巧，Push 进去的队列就是 `PreOrder` ；Pop 出来的队列就是 `InOrder` ；已经知道两个顺序，就可以推出 `PostOrder`。

## 第四周
1. [是否同一棵二叉搜索树](/CodeFiles/IsSameTree.c) + [版本2](/CodeFiles/IsSameTree.cpp)
    ```diff
    - 我用的最愚蠢的办法，分别建立两棵树，然后判定是不是同结构的树
    + 第二种方法是不用建立树，找到根，比他小的一堆在左，大的在右，递归查看左右
    + 第三种方法是何老师教的，建立一棵树，利用flag位，查看结点的路径上没有遇到新的结点，那么就是一样的树
    ```
2. [Root of AVL Tree](/CodeFiles/RootAVLTree.c) + [版本2](/CodeFiles/RootAVLTree.cpp)
    > 难点在于如何能够判断出什么时候该进行四种旋转，递归函数实现，从树的底部到顶部的结点的左右高度判定，判定成立，就进行旋转
   
    > 本来想写不使用迭代版本的，所以insert函数可以不迭代插入，但是revert的时候忘了让旋转后的结构和父节点建立联系，如果按照我原来的思维继续写，那就是遍历，但这样就更复杂了，需要改一次，遍历一次，从头到尾改，肯定不如从脚到头改，所以，最后还是选择，插入的时候顺便检测BalenceFactor，然后进行revert，然后从改变的地方向上更新结点高度

    ```diff
    - 版本2中的inset函数，注意，如何更新root指针的问题
    + 思考，如何不用迭代，代码肯定会更复杂，但可以试试，看后续版本3会不会出来吧，很有可能又要2年才能写版本3，哈哈哈哈
    ``` 
3. [Complete Binary Search Tree](/CodeFiles/CBSTree.c) + [版本2](/CodeFiles/CBSTree.cpp)
    > 需要熟悉完全二叉树的排序方式，使用数组来表示该完全二叉树

    > 这道题做起来就很麻烦，遇到的卡壳点儿在于递归调用的这个函数，我最开始的想法是，从数组起始位到终止位，找到根结点，然后左边就是左子树，右边就是右子树，递归处理左子树，再递归处理右子树，这样子得到的是完全二叉树的先序遍历的结果，接下来也可以做，两个思路，建立树，一个一个插结点就行，或者是找到先序遍历和层序遍历的对应关系，毫无疑问，两种方法都是比较复杂的，查看了网上大家的方法，还是基本性质不熟悉导致卡壳，总的递归调用思路是，递归地将根节点插入到为层序遍历准备的数组中，开头先处理第一个值，这里index来表示，也就是全部的根结点，接下来递归处理它的左结点，下标也就是 index*2，长度就是 left -- (index-1)， 这样全部处理完左子树后，递归处理右子树，下标也就是 index * 2 + 1， 长度就是 （index + 1） -- right

    ```diff
    - 完全二叉树层序遍历的数组，根节点下标是 i, 左节点下标是 i * 2, 右节点下标是 i * 2 + 1
    ```
5. [二叉搜索树的操作集](/CodeFiles/BSTMethods.c)

## 第五周
1. [堆中的路径](/CodeFiles/LoadsInMinheap.cpp)
   > 开始写的程序是按照先把数据都读入，然后从 （n/2）结点开始，从下到上，从右到左，percolate down数据，这样子形成的最小堆不是测试数据的最小堆，所以，又在程序中写了 insert 函数，两种 sort 方法都有了
3. [File Transfer](/CodeFiles/FileTransfer.cpp)
    > 从这里开始，以后就用 C++ 写了，反正 C++，也可以兼容 C，何不利用这次机会，学习一下 C++ 呢？虽然刚开始一眼看上去就是 C 的逻辑和写法，但慢慢来吧

    > 通过陈越老师的讲授，一步步照搬来的，理清思路其实不难，陈越老师所讲的程序，有两个重点，也是老师分别用单独的视频所讲的

    ```diff
    - Find 函数不仅仅是要找到根结点，还要通过不断的递归调用，使得树的高度变低
    + 根结点指向负值，这个负值可以用来表示这个集合中一共有几个结点
    ```
4. [Huffman Codes](/CodeFiles/HuffmanCodes.cpp) + [我的错误版本](/CodeFiles/HuffmanCodes_AmbGeo.cpp)
    > 写得太复杂了，最后修改下来，还有有一个测试点没有通过，最大N&M，不明白为啥，使用AI修改的代码很简洁，后面再改改看，完善完善     

## 第六周
1. [列出连通集](/CodeFiles/ListGroup.cpp)
   > 写出来太复杂了，使用上半角来存储最多10个点的数据太麻烦容易出错，写出来的这个对于第二个测试点过不去，原因未知，待修正，第二个测试提示 “第一个点是单独点，最大N”
   
2. [Saving James Bond](/CodeFiles/SavingJamesBond.cpp)
   > 这道题很简单的，一开始的时候计算结果不正确，排查之后是因为在DFS寻路过程中，如果跳到了一个鳄鱼的位置，后面发现从这个位置找不到正确的路线，那就要退回到上一个位置，所以，每次DFS时，要记录当前位置，再去寻找路线
   
   ```diff
   - vector 已经声明的数组,对其统一初始化，可以使用 resize 函数，也可以使用 fill 函数
   - 也可以预分配数组大小然后使用push_back
   + 求绝对值可以使用 <cmath> 中重载的函数 abs() ，非常方便 
   ```
   
   ```cpp
   std::vector<int> vec;
   vec.resize(10);          // 10个元素，默认初始化为0
   vec.resize(15, -1);       // 调整为15个元素，新元素初始化为-1

   #include <algorithm>
   std::vector<std::string> vec(5); // 5个空字符串
   std::fill(vec.begin(), vec.end(), "default"); // 全部设为"default"

   std::vector<int> optimized;
   optimized.reserve(1000); // 预分配内存，避免push_back时多次重新分配
   for (int i = 0; i < 1000; i++) {
       optimized.push_back(i * 2); // 高效添加元素
   }
   ```
3. [六度空间](/CodeFiles/SixDegreesSpace.cpp)
   > 教训就是永远别用上三角下三角存放数据，真的很不方便

   ```diff
   - cpp 中如何按照设定形式输出，即属于的double 变量有几位小数，可以使用 fixed 
   ```

   ```cpp
   #include <iomanip>

   double item = 1;
   std::cout << std::fixed << std::setprecision(2) << item;
   ```
## 第七周
1. [哈利*波特的考试](/CodeFiles/HerryPotterExam.cpp)
   > 这道题就是“简单”的有权图的多源最短路径的问题，使用 Floyd 算法，跟着陈老师的方法一步一步来其实不难，但我自己觉得从图这里感觉数据结构就变得困难了，当然了，这只是对我来说，这一周的最短路径的课程，很多地方不是很具体，想不清楚，虽然能做出题目来，但是靠着记忆，没有很好地理解概念，没吃透

   ```diff
   + 写题时遇到点儿问题，Data，Dist 数组初始化应该初始化为无穷大
   + 题中要带的动物是想让咒语都不会太长，不是全部咒语加起来太长，真无语啊，我这都不理解
   ```

2. [Saving James Bond - Hard Version(写的第一版，无法通过全部测试点)](/CodeFiles/SavingJamesAgain.cpp)
   </br>
   [按照文章作者的思路，重新写的程序，通过全部测试点](/CodeFiles/SavingJamesAgain1.cpp)
   > 拯救007之前也有这个题目，上次只问了 Bond 能不能活，但是这次要给 Bond 提供路线，而且是最优的路线，其实写代码的时候已经意识到了这一点，甚至我还写了注释，但还是鬼使神差地写下去了，这下好了，从头来过了要，思路其实很简单，就是到了一条鳄鱼头上，看看有没有安全，没有就找下一个跳点，一旦成功了，就结束了
   > 如果从中途中的一个结点开始，有了分叉路，这两条路都可以上岸，代码就没有了判断能力，我思考了很久，也没有什么好办法

    ```diff
   - 我不是 Bond，我是上帝视角，先看哪写鳄鱼可以上岸，再找单源最短路径
   ```

   > 还是没有理解了这部分的知识点，我总感觉，陈老师是个很合格的大学老师，就是不给你讲得很明白，给你留下很多让你自己思考的时间和空间，哈哈哈哈哈哈，言归正传，我从网络上找到一篇文章，文章作者也是初学者，把思路写得特别清楚，一下子就让我打开了思路，强烈建议去看看别人的好思路

   这个作者的文章条理清晰，一看就是很细致的牛人，开个[任意门](https://blog.csdn.net/m0_63938020/article/details/124423084)，去看看大佬的笔迹~~
   
3. [旅游规划](/CodeFiles/TravelMenu.cpp)
   > 不用多说，其实就是比普通的 Dijkstra 算法，多了一个高速费的判断条件，完成了上一题之后，这道题应该算是特别简单，秒了

   ```diff
   + 本题中邻接表中的数据，我是用的申请的结点空间，析构函数进行循环调用的时候，会出现重复删除
   + 因此，在释放了一个空间后，指向这个空间的指针设为 nullptr 是比较合理的习惯
   - 另外，本题多出来的，距离一致时比较高速费的操作，这个环节的进行位置最开始写错了
   - 访问 Dist 最小结点时，循环对它的邻接点写入时，才进行这个操作
   ```

## 第八周
1. [公路村村通](/CodeFiles/VillageRoads.cpp)
   > 我是使用 Kruskal 算法来做这道题的，Kruskal 算法中需要用到并查集的知识，但我最开始写的代码，并查集的操作代码写得不规范，造成了混乱和错误，导致有几个测试点不通过

   ```cpp
   // 以下是 AI 写的操作集，清楚明白，AI 比我强多了
   class UnionFind {
    private:
        std::vector<int> parent;
        std::vector<int> rank;
        
    public:
        UnionFind(int n) {
            parent.resize(n + 1);
            rank.resize(n + 1, 0);
            for (int i = 1; i <= n; i++) {
                parent[i] = i;
            }
        }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
    
    bool merge(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) {
            return false;
        }
        
        // 按秩合并
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
    
    bool isConnected(int x, int y) {
        return find(x) == find(y);
    }
    };
   ```
   
   ```diff
   + 我最开始写的 while 循环条件有一条是访问过也就是成为树的结点是不是全部的结点
   + 但其实这样写是很麻烦的，不看结点，看边就好了，N个结点，想要最小生成树，一定是N-1条边
   + 如果图不连通，那么访问过所有的边后，能选中的边一定小于 N-1
   ```
2. [How Long Does It Take](/CodeFiles/ProjectSchedule.cpp)
   > 按照陈越老师后面讲的实现方法来实现，这道题其实挺简单的，代码写好，基本没有改就能通过全部测试点了
   > 过程需要铭记，实际问题中，点是检查点，边是实际项目进程
   
3. [关键活动](/CodeFiles/KeyAction.cpp)
   > 真服了，看到题目其实觉得很简单，在昨天的基础上改改就行，结果一道题绊住我一天，一是基本概念掌握得不好，导致逻辑上很难理顺
   > 后来就看了一眼陈老师的讲义，一下子豁然贯通

   ```diff
   + 要点1：更新一个检查点的截止时间，是从它的出度的几个活动中看
   +       从几个出度的活动中计算其 min 值，也就是最紧张的时间
   - 要点2：更新检查点的 DeadLine 是从后往前，按照逆拓扑顺序（即拓扑排序的逆序）更新每个顶点的最晚时间
   -       我这里想复杂了，总觉得这样不能保证每个检查点的 DeadLine 时间可以正常算下去，但实际上是可以的
   -       拓扑排序的意思就是前面的基础都铺好了，后面就可以进行了，反过来同样如此
   -       想通之后也就不难了，在之前计算最快完成时间时是使用队列，度为0 的入，然后出，出队的时候入栈不就行了
   + 拓扑排序的终点的 DeadLine 时间是确定的就是最快完成时间，所以，栈的好处就是可以出栈的时候加个条件
   + 判断最开始出来的几个是不是都是终点（因为可能不止一个终点），我是在邻接表中看有没有出度
   + Deep seek建议，建立图的时候不止要建立邻接表，也要建立邻接矩阵
   + Deep seek建议，可以用逆向邻接表来解决问题
   ```

   > 总之吧，程序是没问题的，但是因为思路变来变去，我自己闭门造车的时候想了好几种不对的思路，做了一半就发现有问题，然后重新来，导致程序中有几个不需要的变量和构件，我也懒得改了，但是我觉得最后我的整体的解决方法还是很不错的，其实想通了就是很简单的题目

## 第九周
1. [排序](/CodeFiles/Sort1.cpp)
   > 生成SedgewickSequence遇到点儿麻烦，陈老师讲义上的公式不对，在网上查的实现公式
   > 希尔排序的的实现方式是，比如当前 gap 是5，从下标5开始，以5为间隔，比较5，0，的大小，使用插入排序调整位置，然后比较6，1，...，然后比较 10，5，0 的大小...
   
   ```cpp
   typedef long int ElementType;
    typedef int IndexType;
    
    void generateSedgewickSequence(std::vector<IndexType>& Q, IndexType N)
    {
    	Q.clear();
    	IndexType k = 0;
    	IndexType gap = 0;
    	while (true)
    	{
    		if (k % 2 == 0)
    		{
    			gap = 9 * (pow(2, k) - pow(2, k / 2)) + 1;
    		}
    		else
    		{
    			gap = 8 * pow(2, k) - 6 * pow(2, (k + 1) / 2) + 1;
    		}
    		if (gap > N) break;
    		if (gap > 0)
    			Q.push_back(gap);
    		k++;
    	}
    	std::reverse(Q.begin(), Q.end());
    	return;
    }


   // 希尔排序
    for (auto gap : SedgewickSequence)
    {
    	decltype(gap) i, j;
    	for (i = gap; i < N; i++)
    	{
    		auto Tmp = Data.at(i);
    		for (j = i; j >= gap && Data.at(j - gap) > Tmp; j -= gap)  //注意这里的判断条件
    		{
    			Data.at(j) = Data.at(j - gap);
    		}
    		Data.at(j) = Tmp;
    	}
    }
   ```

2. [Insert or Merge](/CodeFiles/Sort2.cpp)
   > 其实熟悉了插入排序和合并排序，这道题很简单，我的思路就是，每种排序去检测是否进行了一次有效的排序变换，代码中管它叫做 “onestep”

   ```diff
   + 同类型比较，不要 size_t 和 int 进行比较

   - for(auto& tmp : Data) 注意加引用，否则会创建副本，不改变原成员

   + decltype 使用时注意 int 和 int&, 在函数变量中经常容易出错

   - 这道题，如果有例子可以称它是插入排序的结果，也可以称它是合并排序的成果
   - 如果是这样子的情况的话，测试程序默认是插入排序
   - 也正是因为这一点，我最开始的程序无法通过一个测试点
   - 这个测试点提示为：最小N，inQ, 第一次变换无效
   - 我改了代码顺序，让这种情况的序列统一默认是插入排序就通过了
   ```


3. [Insertion or Heap Sort](/CodeFiles/Sort3.cpp)
   > 简单，和上一题基本一样，这次比较两排序是堆排序还是插入排序，在上一题的代码上加个控制堆排序的函数就OK了
   ```diff
   + 完全二叉树​：除了最后一层，其他层都是满的，并且最后一层节点从左到右连续排列

   + 数组表示​：节点在数组中的索引按层级顺序排列
   +   根节点：索引 0
   +   节点 i 的：
   +      左子节点索引：2i + 1
   +      右子节点索引：2i + 2
   +      父节点索引：(i - 1) / 2 (整数除法)

   + 叶子节点从索引 (N/2) 开始
   +   ​最后一级叶子节点​：总数 ≈ 总节点数的一半
   +   在 N 个节点的完全二叉树中：
   +      非叶子节点数：floor(N/2)
   +      叶子节点数：ceil(N/2)

   + 最后一个父节点的索引推导
   +   由于树是自顶向下填充，最后一个父节点是最后一个拥有子节点的节点
   +   ​最后一个父节点必然是：
   +      倒数第二层的最右边节点
   +      其索引为最大的非叶子节点索引

   + 数学证明：
   +   设最后父节点索引为 k，则：
   +   其子节点最大索引为 2k + 2（如果存在）
   +   所有节点索引范围是 [0, N-1]
   +   因此：2k + 2 ≤ N - 1
   +      ⇒ k ≤ (N - 2)/2
   +      ⇒ 最大整数 k = floor(N/2) - 1
   ```

## 第十周
1. [统计工龄](/CodeFiles/Sort4.cpp)
   > 

2. [PAT Judge](/CodeFiles/Sort5.cpp)
   > 

3. [Sort with Swap(0, i)](/CodeFiles/Sort6.cpp)
   > 



















